---
title: "2025-09-03 디자인 패턴- 데코레이터 패턴"
date: "2025-09-03"
status: in-progress
---

## 배운 것
- 데코레이터 패턴의 핵심은 **상속만으로 한계가 있는 동적 기능 확장 문제를, 구성(Composition)과 위임(Delegation)을 통해 해결한다.**
- **상속의 한계**
	클래스 상속만으로 기능을 확장하면, 변화가 생길때마다 새로운 하위 클래스를 만들어야 해서 유연성이 떨어진다. 특히 실행 중에 동적으로 기능을 추가하거나 제거하는 것이 어렵다.
- **구성(Composition)과 위임(Delegation)**
	데코레이터 패턴은 객체를 다른 객체로 감싸서(Wrap) 호출을 위임하는 방식으로 기능을 확장한다. 이를 통해 동적으로 자유롭게 기능을 덧붙이거나 빼낼 수 있다.
- **장식(Decorator)의 의미**
	데코레이터는 **기존 객체와 동일한 인터페이스**를 유지하면서, 추가적인 핵심 기능을 덧씌운다. 슈퍼 클래스의 형식을 따르는 새로운 레이어를 만들어서, 기존 코드를 바꾸지 않고 다양한 변형에 쉽게 적용할 수 있다.
- 언제 쓰일 수 있는가?
	데코레이터 패턴은 같은 인터페이스를 공유하면서, 여러 기능을 동적으로 조합하고 확장해야 할 때 사용된다. 
	예: 입력값에 대해 로깅하거나, 숫자 포맷팅을 덧붙이는 경우.
---
## 예시 코드
함수형 프로그래밍에서의 함수 합성도 위임과 구성을 통해서 해당 데코레이터처럼 보일 수 있다.
```javascript
// 공통 인터페이스: (string) => string
const logInput = (str) => {
	console.log(str);
	return str;
};

const setComma = (str) => {
	const num = Number(str);
	return num.toLocaleString('ko-KR');
};

const compose = (...fns) => (v) => fns.reduce((acc, fn) => fn(acc), v); 

const logComma = compose(logInput, setComma);
console.log(logComma('1234'));
// log: '1234'
// 출력: 1,234
```
하지만 데코레이터 패턴과의 주요한 차이점이라면 데코레이터는 원래 기능은 유지 하되, 외관과 동작을 조금씩 확장해나가는 모습에서 차이점이 있다.
``` javascript
class BaseFormatter {
  format(input) { return input; }
}

class FormatterDecorator {
  constructor(formatter) {
    this.inner = formatter;
  }
  format(input) {
    return this.inner.format(input);
  }
}

class LoggingFormatter extends FormatterDecorator {
  format(input) {
    console.log('input', input);
    return this.inner.format(input);
  }
}

class CommaFormatter extends FormatterDecorator {
  format(input) {
    const n = Number(input).toLocaleString('ko-KR');
    return this.inner.format(n);
  }
}

const f = new LoggingFormatter(new CommaFormatter(new BaseFormatter()));
console.log(f.format('1234'));     
// input 1234
// 출력: 1,234
```

## 다음 할 일
- 